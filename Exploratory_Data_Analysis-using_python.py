# -*- coding: utf-8 -*-
"""Googleplaystore_EDA_python (3).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Lr9u25V1wgFHxMOrlnnRlRt1oOlpe78F

# 1. Importing packages
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

"""# 2. loading dataset into DataFrame """

df = pd.read_csv("Google-Playstore.csv")

df.columns

#no. of rows and columns
df.shape

# provides concise summary of a DataFrame.
df.info()

#descriptive statistics of a DataFrame.
df.describe()

#used to display maximum number of columns
pd.set_option('display.max_columns',None)

total_distinct_apps = df['App Name'].nunique()
print(total_distinct_apps)

df.head(50)

"""#Observation: There are total 2312944 rows, also Total distinct Apps present are 2177944, total of maximum installations is 12,057,630,000 and highest rating reached is 5 means there is  presence of highly rated apps.

# 3.Exploratory Analysis and Visualizations

(1) Analyse Missing data, Visualize the Missing values and Plot Missing values in percentage:
"""

#Checking if any null values present and sorting in ascending
df.isnull().sum().sort_values(ascending=False)

#missing values visualization
import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(12, 8))
sns.heatmap(df.isnull(), cmap='viridis', cbar=False)
plt.title("Missing Values Heatmap", fontsize=16)
plt.xlabel("Columns", fontsize=12)
plt.ylabel("Rows", fontsize=12)
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)

plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Calculate the missing percentage of null values
missing_percentage = (df.isnull().sum() / len(df)) * 100
missing_percentage = missing_percentage[missing_percentage != 0]

# Set the figure size
plt.figure(figsize=(12, 8))

# Sort the missing percentage in ascending order
missing_percentage = missing_percentage.sort_values()

# Plotting the missing percentage
ax = missing_percentage.plot(kind='barh', color='red')
plt.title("Missing Percentage of Null Values", fontsize=20)
plt.xlabel("Percentage", fontsize=14)
plt.ylabel("Columns", fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)

# Add data labels to the bars
for i, v in enumerate(missing_percentage):
    ax.text(v + 0.5, i, f"{v:.2f}%", color='black', fontsize=12, ha='left', va='center')

plt.tight_layout()
plt.show()

"""Observation: Developer website & privacy policy column has the highest number of null values.Columns with a high missing percentage may require imputation techniques or careful consideration before using them in analysis.

# (3) Dropping the null values:
"""

df = df.dropna(subset=['App Name', 'Size', 'Currency', 'Installs', 'Minimum Installs', 'Developer Id', 'Developer Email'])
df.isnull().sum()

"""# (4) Checking for Duplicates:


"""

#checking any duplicates in App name
boolean = df['App Name'].duplicated().any()
boolean

df['App Name'].value_counts()

#Lets check whether data in app name row is identical or not
df[df['App Name']=='Tic Tac Toe']

df['App Id'].duplicated().any()

df['App Id'].value_counts()

"""# (5)	Feature Exploration:

# 1.Installs column feature
"""

#Installs column feature
df['Installs'].unique()

#Removing the + symbol from installs column
df['Installs']=df['Installs'].str.split('+').str[0]

#Replacing the , (comma) symbol from installs column
df['Installs'].replace(',','', inplace=True,regex=True)

# Converting Installs column into integer type
import numpy as np
df['Installs'] = df['Installs'].astype(np.int64)

df['Installs'].dtypes

df['Installs'].unique()

"""# 2.Size column feature"""

#Size feature, In Size feature the data may be in KB, MB, GB, we will make the size into MBâ€™s size.

df['Size'].unique()

#Removing the'M'
df['Size'] = df['Size'].apply(lambda x: str(x).replace('M','') if 'M' in str(x) else x)

df['Size'] = df['Size'].apply(lambda x: float(str(x).replace('k', '').replace(',', '')) / 1000 if 'k' in str(x) else x)

df['Size'] = df['Size'].apply(lambda x: float(str(x).replace('G', '')) * 1000 if 'G' in str(x) else x)

df['Size'] = df['Size'].apply(lambda x: float(x) if str(x).replace('.', '', 1).isdigit() else x)

"""# 3.Free column  feature"""

#lets convert boolean values true or false into "Free" and "Paid" so we can easily analyse whether app is free or paid
df['type'] = np.where(df['Free'] == True ,'Free', 'Paid')
df.drop(['Free'],axis=1, inplace = True)

"""# 4.Content Rating  feature"""

df['Content Rating'].unique()

df['Content Rating']=df['Content Rating'].replace("Unrated","Everyone")
df['Content Rating']=df['Content Rating'].replace("Everyone 10+","Teen")
df['Content Rating']=df['Content Rating'].replace("Mature 17+","Adults")
df['Content Rating']=df['Content Rating'].replace("Adults only 18+","Adults")

df['Content Rating'].unique()

"""# 5.Rating Count  feature"""

df['Rating Count'].unique()

#errors='coerce' argument handles any non-numeric values by converting them to NaN

df['Ratingtype'] = 'NoRatingProvided:'
df['Rating Count'] = pd.to_numeric(df['Rating Count'], errors='coerce')
df.loc[(df['Rating Count'] > 0) & (df['Rating Count'] <= 10000.0), 'Ratingtype'] = 'Less than 10k'
df.loc[(df['Rating Count'] > 10000) & (df['Rating Count'] <= 500000.0), 'Ratingtype'] = 'Between 10k and 500k'
df.loc[(df['Rating Count'] > 500000) & (df['Rating Count'] <= 138557570.0), 'Ratingtype'] = 'More than 500k'
df['Ratingtype'].value_counts()

"""* Questions

# 1.What are the top 10 Categories that are installed from the Google Play Store?
"""

Top_10_categories = df.groupby('Category')['Installs'].sum().sort_values(ascending=False).head(10)
print(Top_10_categories)

"""# 2.Which are the Categories that are getting installed the most in top 10 Categories?"""

most_installed_category = df.groupby('Category')['Installs'].sum().nlargest(1)
print(most_installed_category)

"""# 3.What is the highest rated Category?"""

highest_rated_category = df.groupby('Category')['Rating'].mean().nlargest(1)
print(highest_rated_category )

"""# 4.Which Category has the highest Paid and Free apps ?"""

paid_apps_category = df[df['type'] == 'Paid'].groupby('Category').size().idxmax()
free_apps_category = df[df['type'] == 'Free'].groupby('Category').size().idxmax()
print(paid_apps_category)
print(free_apps_category)

"""# 5.How does the size of the Application impacts the Installation ?"""

import pandas as pd
import matplotlib.pyplot as plt

# Grouping the data by 'Size' and calculating the mean of 'Installs'
grouped_data = df.groupby('Size')['Installs'].mean().reset_index()

# Sort the dataframe by 'Size' in ascending order
grouped_data = grouped_data.sort_values('Size')

# Plotting the graph
plt.figure(figsize=(10, 6))
plt.plot(grouped_data['Size'], grouped_data['Installs'], color="green", marker='o', linestyle='-')
plt.xlabel('Application Size')
plt.ylabel('Average Installations')
plt.title('Impact of Application Size on Installations')
plt.xticks(rotation=90)
plt.grid(True)
plt.tight_layout()
plt.show()

"""# 6.What are the Top 5 Paid Apps based With highest ratings and installs ?"""

# Filtering the DataFrame for paid apps
paid_apps = df[df['type'] == 'Paid']

# Sorting the DataFrame by ratings and installs in descending order
top_paid_apps = paid_apps.sort_values(by=['Rating', 'Installs'], ascending=False).head(5)

print(top_paid_apps[['App Name', 'Rating', 'Installs']])

"""# 7.What are the Top 5 Free Apps based With highest ratings and installs ?"""

# Filtering the DataFrame for paid apps
paid_apps = df[df['type'] == 'Free']

# Sorting the DataFrame by ratings and installs in descending order
top_paid_apps = paid_apps.sort_values(by=['Rating', 'Installs'], ascending=False).head(5)

print(top_paid_apps[['App Name', 'Rating', 'Installs']])

#converting file to csv
df.to_csv('Google-Playstore.csv',index=False)